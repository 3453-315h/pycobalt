# Configuration variables:
#  - $pycobalt_path: Directory containing pycobalt.cna
#  - $pycobalt_python: Location of the Python interpreter (default: /usr/bin/env python3)
#  - $pycobalt_debug_on: Enable debug messages (boolean, default: false)
# 
# Configuration variables for json.cna:
#  - $json_path: Directory containing json.cna (default: $pycobalt_path)
#  - $json_jar_file: File json.jar (default: $json_path . '/jars/json.jar')

if ($pycobalt_debug_on is $null) {
	$pycobalt_debug_on = false;
}

if (!$pycobalt_python) {
	$pycobalt_python = '/usr/bin/env python3'
}

# Write debug message to console
sub _pycobalt_debug {
	if ($pycobalt_debug_on) {
		println('[pycobalt debug] ' . $1);
	}
}

# Write message to console
sub _pycobalt_msg {
	println('[pycobalt] ' . $1);
}

# Write error message to console
sub _pycobalt_error {
	println('[pycobalt error] ' . $1);
}

# Write error message to console and exit
sub _pycobalt_die {
	_pycobalt_error($1);
	exit();
}

# Set default $pycobalt_path
if (!$pycobalt_path) {
	$pycobalt_path = script_resource();
}
_pycobalt_debug('Include path is: ' . $pycobalt_path);

# Set $json_path for json.cna. This is the location of json.cna.
if (!$json_path) {
	$json_path = $pycobalt_path;
}

# Make sure json.cna exists
if (!-exists ($json_path . '/json.cna')) {
	_pycobalt_die('Could not find json.cna. Check $pycobalt_path or $json_path');
}

include($json_path . '/json.cna');

# For special serialization objects
# { name: script_handle }
%_pycobalt_objects = %();

# For managing running scripts
# { file: handle }
%_pycobalt_handles = %();

# Print a stacktrace (for debugging)
sub _pycobalt_stacktrace {
	local('@stack $frame');

	@stack = [[Thread currentThread] getStackTrace];
	_pycobalt_debug('Stack size: ' . size(@stack));
	for $frame (@stack) {
		_pycobalt_debug($frame);
	}
}

# Write a message to a script
sub _pycobalt_write_message {
	local('$handle $name $message %wrapper $marshalled');

	$handle = $1;
	$name = $2;
	$message = $3;

	if (-eof $handle) {
		# Handle is closed
		_pycobalt_debug("Tried to write message to closed script handle");
		return false;
	}

	%wrapper = %(name => $name, message => $message);
	$marshalled = '';
	$marshalled = json_tostring(json_new_jsonobject(%wrapper)) . "\n";
	#_pycobalt_debug('sending ' . $marshalled);
	writeb($handle, $marshalled);

	return true;
}

# Serialize non-primitive object references. This includes Java objects. Java
# objects are opaque to the Python side.
sub _pycobalt_serialize_special {
	local('$arg $item $key $object_prefix $object_name @new_list %new_hash');

	$arg = $1;

	$object_prefix = '<<--pycobalt object-->> ';

	if (($arg isa ^String) || ($arg isa ^Long) || ($arg isa ^Integer) || ($arg isa ^Double)) {
		# primitive type, serializable by json
		return $arg;
	} else if ($arg isa typeOf(@()) || $arg isa ^CollectionWrapper) {
		# recurse lists
		@new_list = @();
		foreach $item ($arg) {
			push(@new_list, _pycobalt_serialize_special($item));
		}
		return @new_list;
	} else if ($arg isa typeOf(%())) {
		# recurse hashes
		%new_hash = %();
		foreach $key => $item ($arg) {
			%new_hash[$key] = _pycobalt_serialize_special($item);
		}
		return %new_hash;
	} else if ($arg is $null) {
		return $arg;
	} else {
		# TODO identityHashCode isn't quite safe enough. we need a better way to do this
		$object_name = [[$arg getClass] getName] . '_' . [System identityHashCode: $arg];
		if ($object_name in %_pycobalt_objects) {
			_pycobalt_debug('Using existing java object named ' . $object_name);
		} else {
			_pycobalt_debug('Adding Java object ' . $arg . ' with name ' . $object_name);
			%_pycobalt_objects[$object_name] = $arg;
		}

		return $object_prefix . $object_name;
	}
}

# Turn a serialized object handle into the object name
sub _pycobalt_resolve_object_handle {
	local('$object_prefix $object_name $handle');

	$handle = $1;
	$object_prefix = '<<--pycobalt object-->> ';

	if (left($handle, strlen($object_prefix)) eq $object_prefix) {
		$object_name = substr($handle, strlen($object_prefix));
		return $object_name;
	} else {
		return $null;
	}
}

# Deserialize non-primitive object references and Python callbacks.
sub _pycobalt_deserialize_special {
	local('$arg $item $key $object_prefix $handle $object_name');
	local('$object $callback_name $callback_prefix $callback @new_list %new_hash');
	local('$data @args');

	$arg = $1;
	$handle = $2;

	$object_prefix = '<<--pycobalt object-->> ';
	$callback_prefix = '<<--pycobalt callback-->> ';
	$bytes_prefix = '<<--pycobalt bytes-->> ';

	if ($arg isa ^String) {
		if (left($arg, strlen($object_prefix)) eq $object_prefix) {
			# it's an object
			$object_name = substr($arg, strlen($object_prefix));
			$object = %_pycobalt_objects[$object_name];
			if (!$object) {
				_pycobalt_msg('Could not find object ' . $object_name);
				return $arg;
			}
			_pycobalt_debug('Found object: ' . $object_name . ' - ' . $object);
			return $object;
		} else if (left($arg, strlen($callback_prefix)) eq $callback_prefix) {
			# it's a callback
			$callback_name = substr($arg, strlen($callback_prefix));

			$callback = lambda({
				@args = @_;
				# XXX stack is already overflowing when there are menu options and such
				# could possibly fork() here to create a new thread/stack
				#@args = _pycobalt_serialize_special(@_);
				_pycobalt_debug('Calling callback: ' . $callback_name);
				%info = %(name => $callback_name, args => @args);
				if (!_pycobalt_write_message($callback_handle, 'callback', %info)) {
					_pycobalt_debug("Callback belongs to a closed script: " . $callback_name);
				}
			}, $callback_handle => $handle, \$callback_name);

			return $callback;
		} else if (left($arg, strlen($bytes_prefix)) eq $bytes_prefix) {
			# it's a bytes object
			$data = substr($arg, strlen($bytes_prefix));
			_pycobalt_debug('Decoding bytes object: ' . $arg);
			$data = [[java.util.Base64 getDecoder] decode: $data];
			_pycobalt_debug('Decoded to: ' . $data);
			return $data;
		} else {
			return $arg;
		}
	} else if ($arg isa typeOf(@())) {
		# recurse lists
		@new_list = @();
		foreach $item ($arg) {
			push(@new_list, _pycobalt_deserialize_special($item, $handle));
		}
		return @new_list;
	} else if ($arg isa typeOf(%())) {
		# recurse hashes
		%new_hash = %();
		foreach $key => $item ($arg) {
			%new_hash[$key] = _pycobalt_deserialize_special($item, $handle);
		}
		return %new_hash;
	} else {
		return $arg;
	}
}

# Make menu
# Fields include:
#   - type: type of item
#   - name: name of item (or menu text)
#   - callback: callback (called before children are produced)
#   - children: child items
#
# Types include:
#   - popup
#   - menu
#   - item
#   - insert_menu
#   - separator
sub _pycobalt_set_menu {
	local('%menu $child $callback @children');

	%menu = $1;

	_pycobalt_debug('Setting up menu ' . %menu);

	sub _pycobalt_menu_callback {
		_pycobalt_debug('In callback for ' . %menu);

		# Call the callback
		if ('callback' in %menu) {
			$callback = %menu['callback'];
			_pycobalt_debug('Calling callback ' . $callback);
			invoke($callback, @_);
		}

		# Deal with children
		if ('children' in %menu) {
			@children = %menu['children'];
			_pycobalt_debug('Children: ' . @children);
			foreach $child (@children) {
				_pycobalt_debug('Dealing with child ' . $child);
				_pycobalt_set_menu($child);
			}
		}
	}

	if (%menu['type'] eq 'popup') {
		_pycobalt_debug('Making popup');
		popup(%menu['name'], lambda(&_pycobalt_menu_callback, \%menu));
	} else if (%menu['type'] eq 'menu') {
		_pycobalt_debug('Making menu');
		menu(%menu['name'], lambda(&_pycobalt_menu_callback, \%menu));
	} else if (%menu['type'] eq 'item') {
		_pycobalt_debug('Making item');
		item(%menu['name'], lambda(&_pycobalt_menu_callback, \%menu));
	} else if (%menu['type'] eq 'insert_menu') {
		_pycobalt_debug('Making insert');
		insert_menu(%menu['name'], $1, $2, $3, $4, $5, $6);
	} else if (%menu['type'] eq 'separator') {
		_pycobalt_debug('Making separator');
		separator();
	} else {
		_pycobalt_error('Invalid menu type: ' . %menu['type']);
	}
}

# Print script message to console
sub _pycobalt_script_message {
	local('$script $message $script_basename');

	$script = $1;
	$message = $2;

	$script_basename = getFileName($script);

	println('[pycobalt ' . $script_basename . '] ' . $message);
}

# Print script error message to console
sub _pycobalt_script_error {
	local('$script $message $script_basename');

	$script = $1;
	$message = $2;

	$script_basename = getFileName($script);

	println('[pycobalt ' . $script_basename . ' error] ' . $message);
}

# Print script debug message to console
sub _pycobalt_script_debug {
	local('$script $message $script_basename');

	$script = $1;
	$message = $2;

	$script_basename = getFileName($script);

	println('[pycobalt ' . $script_basename . ' debug] ' . $message);
}

# Handle a message
sub _pycobalt_handle_message {
	local('$name $message $func $silent $fork');
	local('$i $ret %menu');

	$handle = $1;
	$name = $2;
	$message = $3;

	if ($name eq 'fork') {
		return true;
	} else if ($name eq 'message') {
		_pycobalt_script_message($_pycobalt_script, $message);
	} else if ($name eq 'error') {
		_pycobalt_script_error($_pycobalt_script, $message);
	} else if ($name eq 'debug') {
		_pycobalt_script_debug($_pycobalt_script, $message);
	} else if ($name eq 'call') {
		# call a function
		$func = $message['name'];
		@args = $message['args'];
		$silent = $message['silent'];
		$fork = $message['fork'];
		$sync = $message['sync'];

		$closure_text = 'return ' . $func;

		# silent functions (e.g. bshell!())
		if ($silent) {
			$closure_text .= '!';
		}
		$closure_text .= '(';

		# add arguments (nothing like python's *args in sleep)
		for ($i = 1; $i < size(@args); $i++) {
			$closure_text .= '$' . $i . ',';
		}
		$closure_text .= '$' . $i . ');';

		# this deserializes special objects and callbacks and calls the closure
		sub _pycobalt_closure_caller {
			# deserialize special objects
			# must be performed here so that the callback closures are created
			# in this thread.
			@args = _pycobalt_deserialize_special(@args, $handle);

			_pycobalt_debug('Closure call: ' . $closure_text);
			_pycobalt_debug('Closure args: ' . @args);

			$closure = compile_closure($closure_text);
			$ret = invoke($closure, @args);
			$ret = _pycobalt_serialize_special($ret);

			if ($sync) {
				# write return value
				_pycobalt_write_message($handle, 'return', $ret);
			}
		}

		# call it
		if ($fork) {
			# fork it and call it
			_pycobalt_debug('Forking before calling function');
			fork(&_pycobalt_closure_caller, \$closure_text, \@args, \$handle,
				 \$pycobalt_path, \$json_path, \$json_jar_file, \%_pycobalt_objects,
				 \$pycobalt_debug_on, \$sync);
		} else {
			# call it in this thread, and send return value
			_pycobalt_closure_caller();
		}
	} else if ($name eq 'menu') {
		# create a menu
		_pycobalt_debug('Menu call: ' . $message);
		%menu = _pycobalt_deserialize_special($message, $handle);
		_pycobalt_debug('Deserialized: ' . %menu);
		_pycobalt_set_menu(%menu);
	} else if ($name eq 'delete') {
		# remove serialization reference to object. if it's the only reference
		# the object will be deleted.
		local('$handle')
		$handle = _pycobalt_resolve_object_handle($message);

		if (!$handle) {
			_pycobalt_debug('Tried to delete something that is not an object: ' . $message)
			return;
		}

		if ($message in %_pycobalt_objects) {
			_pycobalt_debug('Deleting object: ' . $handle);
			%_pycobalt_objects[$handle] = $null;
		} else {
			_pycobalt_debug('Tried to delete non-existent object: ' . $handle)
		}
	} else if ($name eq 'eval') {
		# eval some code
		eval($message);
	} else {
		_pycobalt_msg("Unhandled message of type $name - " . $message);
	}
	return false;
}

# Get process stderr
sub _pycobalt_get_stderr {
	local('$handle $source $stream $stderr');

	$handle = $1;

	$source = [$handle getSource];      # java.lang.Process
	$stream = [$source getErrorStream]; # java.io.InputStream

	$stderr = [SleepUtils getIOHandle: $stream, $null];

	return $stderr;
}

# Per-script stderr thread. Just prints stderr to Script Console.
sub _pycobalt_stderr_callback {
	local('$stderr $line');

	$stderr = _pycobalt_get_stderr($_pycobalt_handle);

	while $line (readln($stderr)) {
		# print error message
		_pycobalt_script_error($_pycobalt_script, $line);
	}
}

# Per-script control thread
sub _pycobalt_thread_callback {
	local('$line $obj');

	while $line (readln($_pycobalt_handle)) {
		$obj = json_loads($line);

		if ($obj && 'name' in $obj && 'message' in $obj) {
			if (_pycobalt_handle_message($_pycobalt_handle, $obj['name'], $obj['message'])) {
				return true;
			}
		} else {
			# it's not a control message so assume it's a message
			_pycobalt_script_message($_pycobalt_script, $line);
		}
	}

	_pycobalt_msg('Script process exited: ' . $_pycobalt_script);
	remove(%_pycobalt_handles, $_pycobalt_handle);

	if (!-eof $_pycobalt_handle) {
		closef($_pycobalt_handle);
	}

	return false;
}

# Return a filename for a handle
sub python_handle_to_file {
	local('$find_handle $file $handle');

	$find_handle = $1;

	foreach $file => $handle (%_pycobalt_handles) {
		if ($find_handle eq $handle) {
			return $file;
		}
	}

	return $null;
}

# Return handle for a filename
sub python_file_to_handle {
	local('$find_name');

	$find_name = $1;

	if ($find_name in %_pycobalt_handles) {
		return %_pycobalt_handles[$find_name];
	} else {
		return $null;
	}
}

# Start a Python script
sub python {
	local('$error $stderr_thread $script_thread $existing_handle');

	# global variable
	$_pycobalt_script = $1;

	# check if this script is already running
	$existing_handle = python_file_to_handle($_pycobalt_script);
	if ($existing_handle) {
		_pycobalt_msg($_pycobalt_script . ' is already running. Restarting.');
		python_stop($existing_handle);
	}

	# execute the script
	_pycobalt_msg('Executing script ' . $_pycobalt_script);
	# global variable
	$_pycobalt_handle = exec($pycobalt_python . ' ' . $_pycobalt_script);
	if (checkError($error)) {
		_pycobalt_msg("Failed to execute script '" . $_pycobalt_script . "': " . $error);
		return $null;
	}

	# start the stderr handler
	$stderr_thread = fork(&_pycobalt_stderr_callback, \$_pycobalt_handle, \$_pycobalt_script);

	# run without forking first so we can register context menu stuff
	# TODO make this time out so we don't freeze up cobaltstrike if the script
	# loops without calling engine.fork()
	if (_pycobalt_thread_callback()) {
		# then fork it
		$script_thread = fork(&_pycobalt_thread_callback, \$_pycobalt_handle,
			\$_pycobalt_script, \%_pycobalt_objects, \$pycobalt_path,
			\$json_path, \$json_jar_file, \$pycobalt_debug_on, \%_pycobalt_handles);
	}

	%_pycobalt_handles[$_pycobalt_script] = $_pycobalt_handle;

	return $_pycobalt_handle;
}

# Stop a Python script with its handle
sub python_stop {
	local('$handle $file');

	$handle = $1;

	$file = python_handle_to_file($handle);
	if ($file) {
		_pycobalt_msg("Asking script to stop: " . $file);
		_pycobalt_write_message($handle, 'stop');
		return true;
	} else {
		_pycobalt_error("Called python_stop on an unrecognized handle");
		return false;
	}
}

# Stop a Python script with its filename
# The filename must exactly match the filename passed to python()
sub python_stop_file {
	local('$handle $handle $file');

	$file = $1;

	$handle = python_file_to_handle($file);
	if ($handle) {
		python_stop($handle);
	} else {
		_pycobalt_error("Didn't find a handle for " . $file);
	}
}

# Stop all Python scripts
sub python_stop_all {
	local('$handle');

	foreach $handle (values(%_pycobalt_handles)) {
		python_stop($handle);
	}
}

# Eval arbitrary code within the context of a Python script
sub python_eval {
	local('$handle $code');

	$handle = $1;
	$code = $2;

	_pycobalt_write_message($handle, 'eval', $code);
}

# Get a list of running filenames
sub python_files {
	return keys(%_pycobalt_handles);
}

# Get a list of running handles
sub python_handles {
	return values(%_pycobalt_handles);
}

# Start a Python script
command python {
	local('$file');

	$file = $1;

	python($file);
}

# Stop a Python script by its filename
command python-stop {
	local('$file');

	$file = $1;

	python_stop_file($file);
}

# Stop all Python scripts
command python-stop-all {
	python_stop_all();
}

# List filenames for running scripts. These filenames may be passed to
# python-stop and python-eval.
command python-list {
	local('$file @files');

	@files = python_files();
	if (size(@files)) {
		_pycobalt_msg("Running scripts:")
		foreach $file (python_files()) {
			println(" - " . $file);
		}
	} else {
		_pycobalt_msg("No running scripts")
	}
}

# Eval arbitrary code within the context of a Python script
command python-eval {
	local('$file $code $handle');

	$file = $1;
	$code = $2;

	$handle = python_file_to_handle($file);
	if ($handle) {
		python_eval($handle, $code);
	} else {
		_pycobalt_error("Didn't find a handle for " . $file);
	}
}
