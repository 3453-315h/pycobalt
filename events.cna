#
# Dispatch wrappers for all events. See events.py for the Python side.
#
# Generated by a ghetto ass vim macro
#

# * (event)
# This event fires whenever any Aggressor Script event fires.
# 
# Arguments
# $1 - the original event name
# ... - the arguments to the event
# Example
# # event spy script
# on * {
# 	println("[ $+ $1 $+ ]: " . subarray(@_, 1));
# }
#on * {
#	dispatch_event('any', @_);
#}

# beacon_checkin
# Fired when a Beacon checkin acknowledgement is posted to a Beacon's console.
# 
# Arguments
# $1 - the ID of the beacon
# $2 - the text of the message
# $3 - when this message occurred
on beacon_checkin {
	dispatch_event('beacon_checkin', @_);
}

# beacon_error
# Fired when an error is posted to a Beacon's console.
# 
# Arguments
# $1 - the ID of the beacon
# $2 - the text of the message
# $3 - when this message occurred
on beacon_error {
	dispatch_event('beacon_error', @_);
}

# beacon_indicator
# Fired when an indicator of compromise notice is posted to a Beacon's console.
# 
# Arguments
# $1 - the ID of the beacon
# $2 - the user responsible for the input 
# $3 - the text of the message
# $4 - when this message occurred
on beacon_indicator {
	dispatch_event('beacon_indicator', @_);
}

# beacon_initial
# Fired when a Beacon calls home for the first time.
# 
# Arguments
# $1 - the ID of the beacon that called home.
# Example
# on beacon_initial {
# 	# list network connections
# 	bshell($1, "netstat -na | findstr \"ESTABLISHED\"");
# 	
# 	# list shares
# 	bshell($1, "net use");
# 	
# 	# list groups
# 	bshell($1, "whoami /groups");
# }
on beacon_initial {
	dispatch_event('beacon_initial', @_);
}

# beacon_initial_empty
# Fired when a DNS Beacon calls home for the first time. At this point, no metadata has been exchanged.
# 
# Arguments
# $1 - the ID of the beacon that called home.
# Example
# on beacon_initial_empty {
# 	binput($1, "[Acting on new DNS Beacon]");
# 	
# 	# change the data channel to DNS TXT
# 	bmode($1, "dns-txt");
# 	
# 	# request the Beacon checkin and send its metadata
# 	bcheckin($1);
# }
on beacon_initial_empty {
	dispatch_event('beacon_initial_empty', @_);
}

# beacon_input
# Fired when an input message is posted to a Beacon's console.
# 
# Arguments
# $1 - the ID of the beacon
# $2 - the user responsible for the input 
# $3 - the text of the message
# $4 - when this message occurred
on beacon_input {
	dispatch_event('beacon_input', @_);
}

# beacon_mode
# Fired when a mode change acknowledgement is posted to a Beacon's console.
# 
# Arguments
# $1 - the ID of the beacon
# $2 - the text of the message
# $3 - when this message occurred
on beacon_mode {
	dispatch_event('beacon_mode', @_);
}

# beacon_output
# Fired when output is posted to a Beacon's console.
# 
# Arguments
# $1 - the ID of the beacon
# $2 - the text of the message
# $3 - when this message occurred
on beacon_output {
	dispatch_event('beacon_output', @_);
}

# beacon_output_alt
# Fired when (alternate) output is posted to a Beacon's console. What makes for alternate output? It's just different presentation from normal output.
# 
# Arguments
# $1 - the ID of the beacon
# $2 - the text of the message
# $3 - when this message occurred
on beacon_output_alt {
	dispatch_event('beacon_output_alt', @_);
}

# beacon_output_jobs
# Fired when jobs output is sent to a Beacon's console.
# 
# Arguments
# $1 - the ID of the beacon
# $2 - the text of the jobs output
# $3 - when this message occurred
on beacon_output_jobs {
	dispatch_event('beacon_output_jobs', @_);
}

# beacon_output_ls
# Fired when ls output is sent to a Beacon's console.
# 
# Arguments
# $1 - the ID of the beacon
# $2 - the text of the ls output
# $3 - when this message occurred
on beacon_output_ls {
	dispatch_event('beacon_output_ls', @_);
}

# beacon_output_ps
# Fired when ps output is sent to a Beacon's console.
# 
# Arguments
# $1 - the ID of the beacon
# $2 - the text of the ps output
# $3 - when this message occurred
on beacon_output_ps {
	dispatch_event('beacon_output_ps', @_);
}

# beacon_tasked
# Fired when a task acknowledgement is posted to a Beacon's console.
# 
# Arguments
# $1 - the ID of the beacon
# $2 - the text of the message
# $3 - when this message occurred
on beacon_tasked {
	dispatch_event('beacon_tasked', @_);
}

# beacons
# Fired when the team server sends over fresh information on all of our Beacons. This occurs about once each second.
# 
# Arguments
# $1 - an array of dictionary objects with metadata for each Beacon.
# disconnect
# Fired when this Cobalt Strike becomes disconnected from the team server.
# 
#on beacons {
#	dispatch_event('beacons', @_);
#}

# event_action
# Fired when a user performs an action in the event log. This is similar to an action on IRC (the /me command)
# 
# Arguments
# $1 - who the message is from
# $2 - the contents of the message
# $3 - the time the message was posted
on event_action {
	dispatch_event('event_action', @_);
}

# event_beacon_initial
# Fired when an initial beacon message is posted to the event log.
# 
# Arguments
# $1 - the contents of the message
# $2 - the time the message was posted
on event_beacon_initial {
	dispatch_event('event_beacon_initial', @_);
}

# event_join
# Fired when a user connects to the team server
# 
# Arguments
# $1 - who joined the team server
# $2 - the time the message was posted
on event_join {
	dispatch_event('event_join', @_);
}

# event_newsite
# Fired when a new site message is posted to the event log.
# 
# Arguments
# $1 - who setup the new site
# $2 - the contents of the new site message
# $3 - the time the message was posted
on event_newsite {
	dispatch_event('event_newsite', @_);
}

# event_notify
# Fired when a message from the team server is posted to the event log.
# 
# Arguments
# $1 - the contents of the message
# $2 - the time the message was posted
on event_notify {
	dispatch_event('event_notify', @_);
}

# event_nouser
# Fired when the current Cobalt Strike client tries to interact with a user who is not connected to the team server.
# 
# Arguments
# $1 - who is not present
# $2 - the time the message was posted
on event_nouser {
	dispatch_event('event_nouser', @_);
}

# event_private
# Fired when a private message is posted to the event log.
# 
# Arguments
# $1 - who the message is from
# $2 - who the message is directed to
# $3 - the contents of the message
# $4 - the time the message was posted
on event_private {
	dispatch_event('event_private', @_);
}

# event_public
# Fired when a public message is posted to the event log.
# 
# Arguments
# $1 - who the message is from
# $2 - the contents of the message
# $3 - the time the message was posted
on event_public {
	dispatch_event('event_public', @_);
}

# event_quit
# Fired when someone disconnects from the team server.
# 
# Arguments
# $1 - who left the team server
# $2 - the time the message was posted
on event_quit {
	dispatch_event('event_quit', @_);
}

## heartbeat_10m
## Fired every ten minutes
## 
#on heartbeat_10m {
#	dispatch_event('heartbeat_10m', @_);
#}
#
## heartbeat_10s
## Fired every ten seconds
## 
## heartbeat_15m
## Fired every fifteen minutes
## 
#on heartbeat_10s {
#	dispatch_event('heartbeat_10s', @_);
#}
#
## heartbeat_15s
## Fired every fifteen seconds
## 
#on heartbeat_15s {
#	dispatch_event('heartbeat_15s', @_);
#}
#
## heartbeat_1m
## Fired every minute
## 
#on heartbeat_1m {
#	dispatch_event('heartbeat_1m', @_);
#}
#
## heartbeat_1s
## Fired every second
## 
#on heartbeat_1s {
#	dispatch_event('heartbeat_1s', @_);
#}
#
## heartbeat_20m
## Fired every twenty minutes
## 
#on heartbeat_20m {
#	dispatch_event('heartbeat_20m', @_);
#}
#
## heartbeat_30m
## Fired every thirty minutes
## 
#on heartbeat_30m {
#	dispatch_event('heartbeat_30m', @_);
#}
#
## heartbeat_30s
## Fired every thirty seconds
## 
#on heartbeat_30s {
#	dispatch_event('heartbeat_30s', @_);
#}
#
## heartbeat_5m
## Fired every five minutes
## 
#on heartbeat_5m {
#	dispatch_event('heartbeat_5m', @_);
#}
#
## heartbeat_5s
## Fired every five seconds
## 
#on heartbeat_5s {
#	dispatch_event('heartbeat_5s', @_);
#}
#
## heartbeat_60m
## Fired every sixty minutes
## 
#on heartbeat_60m {
#	dispatch_event('heartbeat_60m', @_);
#}

# keylogger_hit
# Fired when there are new results reported to the web server via the cloned site keystroke logger.
# 
# Arguments
# $1 - external address of visitor
# $2 - reserved
# $3 - the logged keystrokes
# $4 - the phishing token for these recorded keystrokes.
on keylogger_hit {
	dispatch_event('keylogger_hit', @_);
}

# profiler_hit
# Fired when there are new results reported to the System Profiler.
# 
# Arguments
# $1 - external address of visitor
# $2 - de-cloaked internal address of visitor (or "unknown")
# $3 - visitor's User-Agent
# $4 - a dictionary containing the applications.
# $5 - the phishing token of the visitor (use &tokenToEmail to resolve to an email address)
on profiler_hit {
	dispatch_event('profiler_hit', @_);
}

# ready
# Fired when this Cobalt Strike client is connected to the team server and ready to act.
# 
on ready {
	dispatch_event('ready', @_);
}

# sendmail_done
# Fired when a phishing campaign completes
# 
# Arguments
# $1 - the campaign ID
on sendmail_done {
	dispatch_event('sendmail_done', @_);
}

# sendmail_post
# Fired after a phish is sent to an email address.
# 
# Arguments
# $1 - the campaign ID
# $2 - the email we're sending a phish to
# $3 - the status of the phish (e.g., SUCCESS)
# $4 - the message from the mail server
on sendmail_post {
	dispatch_event('sendmail_post', @_);
}

# sendmail_pre
# Fired before a phish is sent to an email address.
# 
# Arguments
# $1 - the campaign ID
# $2 - the email we're sending a phish to
on sendmail_pre {
	dispatch_event('sendmail_pre', @_);
}

# sendmail_start
# Fired when a new phishing campaign kicks off.
# 
# Arguments
# $1 - the campaign ID
# $2 - number of targets
# $3 - local path to attachment
# $4 - the bounce to address
# $5 - the mail server string
# $6 - the subject of the phishing email
# $7 - the local path to the phishing template
# $8 - the URL to embed into the phish
on sendmail_start {
	dispatch_event('sendmail_start', @_);
}

# ssh_checkin
# Fired when an SSH client checkin acknowledgement is posted to an SSH console.
# 
# Arguments
# $1 - the ID of the session
# $2 - the text of the message
# $3 - when this message occurred
on ssh_checkin {
	dispatch_event('ssh_checkin', @_);
}

# ssh_error
# Fired when an error is posted to an SSH console.
# 
# Arguments
# $1 - the ID of the session
# $2 - the text of the message
# $3 - when this message occurred
on ssh_error {
	dispatch_event('ssh_error', @_);
}

# ssh_indicator
# Fired when an indicator of compromise notice is posted to an SSH console.
# 
# Arguments
# $1 - the ID of the session
# $2 - the user responsible for the input 
# $3 - the text of the message
# $4 - when this message occurred
on ssh_indicator {
	dispatch_event('ssh_indicator', @_);
}

# ssh_initial
# Fired when an SSH session is seen for the first time.
# 
# Arguments
# $1 - the ID of the session
# Example
# on ssh_initial {
# 	if (-isadmin $1) {
# 		bshell($1, "cat /etc/shadow");
# 	}
# }
on ssh_initial {
	dispatch_event('ssh_initial', @_);
}

# ssh_input
# Fired when an input message is posted to an SSH console.
# 
# Arguments
# $1 - the ID of the session
# $2 - the user responsible for the input 
# $3 - the text of the message
# $4 - when this message occurred
on ssh_input {
	dispatch_event('ssh_input', @_);
}

# ssh_output
# Fired when output is posted to an SSH console.
# 
# Arguments
# $1 - the ID of the session
# $2 - the text of the message
# $3 - when this message occurred
on ssh_output {
	dispatch_event('ssh_output', @_);
}

# ssh_output_alt
# Fired when (alternate) output is posted to an SSH console. What makes for alternate output? It's just different presentation from normal output.
# 
# Arguments
# $1 - the ID of the session
# $2 - the text of the message
# $3 - when this message occurred
on ssh_output_alt {
	dispatch_event('ssh_output_alt', @_);
}

# ssh_tasked
# Fired when a task acknowledgement is posted to an SSH console.
# 
# Arguments
# $1 - the ID of the session
# $2 - the text of the message
# $3 - when this message occurred
on ssh_tasked {
	dispatch_event('ssh_tasked', @_);
}

# web_hit
# Fired when there's a new hit on Cobalt Strike's web server.
# 
# Arguments
# $1 - the method (e.g., GET, POST)
# $2 - the requested URI
# $3 - the visitor's address
# $4 - the visitor's User-Agent string
# $5 - the web server's response to the hit (e.g., 200)
# $6 - the size of the web server's response
# $7 - a description of the handler that processed this hit.
# $8 - a dictionary containing the parameters sent to the web server
# $9 - the time when the hit took place.
on web_hit {
	dispatch_event('web_hit', @_);
}
