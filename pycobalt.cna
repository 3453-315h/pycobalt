# results = python('<filename>', args...)
# inside python:
#   sys.argv is passed to helper function for parsing
#   any aggressor function works
#   anything printed is either:
#     - printed to console
#     - or ran as an aggressor command (magic prefix)
#     - or interpreted as a return value for the function (magic prefix)
#
# test.cna:
#
#    python('find.py', '1')
#    python_stop('find.py')
#
# find.py:
#
#    def callback():
#        for beacon in beacons():
#            print(beacon['bid'])
#
#    beacon_initial(callback)
#    beacon_alias('test', callback)
#
# 1. aggressor gets new beacon
# 2. aggressor sends 'event beacon_initial' to python
# 3. python calls beacon_initial callbacks
# 4. python calls beacons()
# 5. python beacons() prints '<aggressor> beacons()'
# 6. aggressor reads the line and calls beacons()
# 7. aggressor marshals beacons() output and sends to python
# 8. python beacons() takes the return line and unmarshalls it. returns it
# 9. python prints the beacon bid
# 10. aggressor reads this line and prints it to script console (e.g. '[find.py] 3')

include(script_resource('pycobalt/json.cna'));

# Process handles
%python_handles = %();
$python_handles_lock = semaphore();

# For special serialization objects
%python_callbacks = %();
%python_objects = %();

sub find_handle {
	$script = $1;
	return %python_handles[$script];
}

sub find_script {
	$handle = $1;

	foreach $key => $value (%python_handles) {
		if ($value is $handle) {
			return $key;
		}
	}
	return $null;
}

sub debug {
	$debug_on = true;
	if ($debug_on) {
		println('[pycobalt debug] ' . $1);
	}
}

sub msg {
	println('[pycobalt] ' . $1);
}

sub write_message {
	$handle = $1;
	$name = $2;
	$message = $3;

	if (-eof $handle) {
		# Handle is closed
		debug('EOF!');
		return;
	}

	%wrapper = %('name' => $name, 'message' => $message);
	$marshalled = '';
	$marshalled = tostring(new_jsonobject(%wrapper)) . "\n";
	#debug('sending ' . $marshalled);
	writeb($handle, $marshalled);
}

sub serialize_special {
	local('$arg $item $key $object_prefix');

	$arg = $1;

	$object_prefix = '<<object>> ';

	if ($arg isa ^String || $arg isa ^Long || $arg isa ^Integer || $arg isa ^Double) {
		# primitive type, serializable by json
		return $arg;
	} else if ($arg isa typeOf(@())) {
		# recurse lists
		for $item ($arg) {
			$item = serialize_special($item);
		}
		return $arg;
	} else if ($arg isa typeOf(%())) {
		# recurse hashes
		foreach $key => $item ($arg) {
			$arg[$key] = serialize_special($item);
		}
		return $arg;
	} else {
		# TODO serialize
		return $arg;
	}
}

sub deserialize_special {
	local('$arg $item $key $object_prefix');

	$arg = $1;

	$object_prefix = '<<object>> ';
	if ($arg isa ^String) {
		$prefix_len = strlen($object_prefix);
		# fuck this language
		if (left($arg, $prefix_len) eq $object_prefix) {
			$object_name = substr($arg, $prefix_len);
			$object = %python_objects[$object_name];
			if (!$object) {
				msg('could not find object ' . $object_name);
				return $arg;
			}
			debug('found object: ' . $object_name . ' - ' . $object);
			return $object;
		} else {
			return $arg;
		}
	} else if ($arg isa typeOf(@())) {
		# recurse lists
		for $item ($arg) {
			$item = deserialize_special($item);
		}
		return $arg;
	} else if ($arg isa typeOf(%())) {
		# recurse hashes
		foreach $key => $item ($arg) {
			$arg[$key] = deserialize_special($item);
		}
		return $arg;
	} else {
		return $arg;
	}
}

sub handle_message {
	$handle = $1;
	$name = $2;
	$message = $3;

	if ($name eq 'fork') {
		debug('forking now');
		return true;
	} else if ($name eq 'message') {
		# print message
		println('[pycobalt script] ' . $message);
	} else if ($name eq 'debug') {
		# print debug message
		println('[pycobalt script debug] ' . $message);
	} else if ($name eq 'error') {
		# print error message
		println('[pycobalt script error] ' . $message);
	} else if ($name eq 'call') {
		# call a function
		$func = $message['name'];
		@args = $message['args'];
		$silent = $message['silent'];
		$closure_text = 'return ' . $func;

		# deserialize special objects
		@args = deserialize_special(@args);

		# resolve callbacks as needed
		foreach $arg (@args) {
			$prefix = '<<callback>> ';
			$len = strlen($prefix);
			if (left($arg, $len) eq $prefix) {
				$callback_name = substr($arg, $len);
				$callback = %python_callbacks[$callback_name];
				#$arg = function('&' . $callback_name);
				$arg = $callback;
				if (!$arg) {
					msg('could not find closure: ' . $callback_name);
					return false;
				}
			}
		}

		# silent functions (e.g. bshell!())
		if ($silent) {
			$closure_text .= '!';
		}
		$closure_text .= '(';

		# add arguments (nothing like python's *args in sleep)
		for ($i = 1; $i < size(@args); $i++) {
			$closure_text .= '$' . $i . ',';
		}
		$closure_text .= '$' . $i . ');';

		debug('closure call: ' . $closure_text);
		debug('closure args: ' . @args);
		$closure = compile_closure($closure_text);
		$ret = invoke($closure, @args);
		$ret = serialize_special($ret);
		write_message($handle, 'return', $ret);
	} else if ($name eq 'command') {
		$callback = lambda({
			@args = $1;
			%info = %('name' => $command_name, 'args' => @args);
			write_message($command_handle, 'command', %info);
		}, $command_handle => $handle, $command_name => $message);
		debug('registering command ' . $message);
		command($message, $callback);
	} else if ($name eq 'alias') {
		$callback = lambda({
			%info = %('name' => $alias_name, 'args' => @_);
			write_message($alias_handle, 'alias', %info);
		}, $alias_handle => $handle, $alias_name => $message);
		debug('registering alias ' . $message);
		alias($message, $callback);
	} else if ($name eq 'callback') {
		$callback = lambda({
			%info = %('name' => $callback_name, 'args' => @_);
			write_message($callback_handle, 'callback', %info);
		}, $callback_handle => $handle, $callback_name => $message);

		debug('registering callback ' . $message);
		%python_callbacks[$message] = $callback;
		#setf('&' . $message, $callback);
	} else if ($name eq 'event') {
		$callback = lambda({
			%info = %('name' => $event_name, 'args' => @_);
			write_message($event_handle, 'event', %info);
		}, $event_handle => $handle, $event_name => $message);
		debug('registering event ' . $message);
		on($message, $callback);
	} else if ($name eq 'eval') {
		# eval some code
		eval($message);
	} else {
		msg("unhandled message of type $name : " . $message);
	}
	return false;
}

sub thread_callback {
	while $line (readln($handle)) {
		$obj = from_json($line);

		if ($obj) {
			#debug('received ' . $obj);
			if (handle_message($handle, $obj['name'], $obj['message'])) {
				return true;
			}
		} else {
			msg('failed to parse json: ' . $line);
		}
	}

	msg('closing script ' . $script);

	if (!-eof $handle) {
		closef($handle);
	}
	return false;
}

sub python {
	$script = $1;

	msg('executing script ' . $script);
	$handle = exec($script);
	if (checkError($error)) {
		msg("failed to execute script '" . $script . "': " . $error);
	}

	# Close existing
	acquire($python_handles_lock);
	if (%python_handles[$script]) {
		debug('closing existing handle');
		closef(%python_handles[$script]);
	}

	# We parse the results in the same thread until we receive a fork command.
	# This allows us to register aliases and stuff.
	%python_handles[$script] = $handle;
	release($python_handles_lock);
	if (thread_callback(\$handle, \$script)) {
		fork(&thread_callback, \$handle, \$script, \%python_callbacks);
	}
}

sub python_stop {
	$script = $1;

	# Remove it from handles list
	acquire($python_handles_lock);
	if (%python_handles[$script]) {
		closef(%python_handles[$script]);
		%python_handles[$script] = $null;
	}
	release($python_handles_lock);
}
