include(script_resource('pycobalt/json.cna'));

# Process handles
%python_handles = %();
$python_handles_lock = semaphore();

# For special serialization objects
# { name: handle }
%python_objects = %();

sub find_handle {
	$script = $1;
	return %python_handles[$script];
}

sub find_script {
	$handle = $1;

	foreach $key => $value (%python_handles) {
		if ($value is $handle) {
			return $key;
		}
	}
	return $null;
}

sub debug {
	$debug_on = true;
	if ($debug_on) {
		println('[pycobalt debug] ' . $1);
	}
}

sub msg {
	println('[pycobalt] ' . $1);
}

sub write_message {
	$handle = $1;
	$name = $2;
	$message = $3;

	if (-eof $handle) {
		# Handle is closed
		debug('EOF!');
		return;
	}

	%wrapper = %('name' => $name, 'message' => $message);
	$marshalled = '';
	$marshalled = tostring(new_jsonobject(%wrapper)) . "\n";
	#debug('sending ' . $marshalled);
	writeb($handle, $marshalled);
}

sub serialize_special {
	local('$arg $item $key $object_prefix');

	$arg = $1;

	$object_prefix = '<<object>> ';

	if ($arg isa ^String || $arg isa ^Long || $arg isa ^Integer || $arg isa ^Double) {
		# primitive type, serializable by json
		return $arg;
	} else if ($arg isa typeOf(@())) {
		# recurse lists
		foreach $item ($arg) {
			$item = serialize_special($item);
		}
		return $arg;
	} else if ($arg isa typeOf(%())) {
		# recurse hashes
		foreach $key => $item ($arg) {
			$arg[$key] = serialize_special($item);
		}
		return $arg;
	} else {
		# TODO serialize
		return $arg;
	}
}

sub deserialize_special {
	local('$arg $item $key $object_prefix $handle $object_name $object $callback_prefix $callback $callback_name');

	$arg = $1;
	$handle = $2;

	$object_prefix = '<<object>> ';
	$callback_prefix = '<<callback>> ';

	if ($arg isa ^String) {
		if (left($arg, strlen($object_prefix)) eq $object_prefix) {
			# it's an object
			$object_name = substr($arg, strlen($object_prefix));
			$object = %python_objects[$object_name];
			if (!$object) {
				msg('could not find object ' . $object_name);
				return $arg;
			}
			debug('found object: ' . $object_name . ' - ' . $object);
			return $object;
		} else if (left($arg, strlen($callback_prefix)) eq $callback_prefix) {
			# it's a callback
			$callback_name = substr($arg, strlen($callback_prefix));

			$callback = lambda({
				%info = %('name' => $callback_name, 'args' => @_);
				write_message($callback_handle, 'callback', %info);
			}, $callback_handle => $handle, \$callback_name);

			return $callback;
		} else {
			return $arg;
		}
	} else if ($arg isa typeOf(@())) {
		# recurse lists
		foreach $item ($arg) {
			$item = deserialize_special($item, $handle);
		}
		return $arg;
	} else if ($arg isa typeOf(%())) {
		# recurse hashes
		foreach $key => $item ($arg) {
			$arg[$key] = deserialize_special($item, $handle);
		}
		return $arg;
	} else {
		return $arg;
	}
}

sub handle_message {
	$handle = $1;
	$name = $2;
	$message = $3;

	if ($name eq 'fork') {
		debug('forking now');
		return true;
	} else if ($name eq 'message') {
		# print message
		println('[pycobalt script] ' . $message);
	} else if ($name eq 'debug') {
		# print debug message
		println('[pycobalt script debug] ' . $message);
	} else if ($name eq 'error') {
		# print error message
		println('[pycobalt script error] ' . $message);
	} else if ($name eq 'call') {
		# call a function
		$func = $message['name'];
		@args = $message['args'];
		$silent = $message['silent'];
		$fork = $message['fork'];

		$closure_text = 'return ' . $func;

		# silent functions (e.g. bshell!())
		if ($silent) {
			$closure_text .= '!';
		}
		$closure_text .= '(';

		# add arguments (nothing like python's *args in sleep)
		for ($i = 1; $i < size(@args); $i++) {
			$closure_text .= '$' . $i . ',';
		}
		$closure_text .= '$' . $i . ');';

		sub closure_caller {
			# deserialize special objects
			# must be performed here so that the callback closures are created
			# in this thread.
			@args = deserialize_special(@args, $handle);

			debug('closure call: ' . $closure_text);
			debug('closure args: ' . @args);

			$closure = compile_closure($closure_text);
			$ret = invoke($closure, @args);
			$ret = serialize_special($ret);
			return $ret;
		}

		if ($fork) {
			# fork it
			debug('forking before calling function');
			fork(&closure_caller, \$closure_text, \@args, \$handle);
		} else {
			# call it in this thread, and send return value
			$ret = closure_caller();
			write_message($handle, 'return', $ret);
		}
	} else if ($name eq 'command') {
		$callback = lambda({
			@args = $1;
			%info = %('name' => $command_name, 'args' => @args);
			write_message($command_handle, 'command', %info);
		}, $command_handle => $handle, $command_name => $message);
		debug('registering command ' . $message);
		command($message, $callback);
	} else if ($name eq 'alias') {
		# forked to prevent it from calling into the main thread, which will be
		# busy reading from the python script.
		sub register_alias {
			$callback = lambda({
				%info = %('name' => $alias_name, 'args' => @_);
				write_message($alias_handle, 'alias', %info);
			}, \$alias_handle, \$alias_name);
			debug('registering alias: ' . $alias_name);
			alias($alias_name, $callback);
		}
		fork(&register_alias, $alias_name => $message, $alias_handle => $handle);
	} else if ($name eq 'event') {
		$callback = lambda({
			%info = %('name' => $event_name, 'args' => @_);
			write_message($event_handle, 'event', %info);
		}, $event_handle => $handle, $event_name => $message);
		debug('registering event ' . $message);
		on($message, $callback);
	} else if ($name eq 'eval') {
		# eval some code
		eval($message);
	} else {
		msg("unhandled message of type $name : " . $message);
	}
	return false;
}

sub thread_callback {
	while $line (readln($handle)) {
		$obj = from_json($line);

		if ($obj) {
			#debug('received ' . $obj);
			if (handle_message($handle, $obj['name'], $obj['message'])) {
				return true;
			}
		} else {
			msg('failed to parse json: ' . $line);
		}
	}

	msg('closing script ' . $script);

	if (!-eof $handle) {
		closef($handle);
	}
	return false;
}

sub python {
	$script = $1;

	msg('executing script ' . $script);
	$handle = exec($script . ' 2>&1');
	if (checkError($error)) {
		msg("failed to execute script '" . $script . "': " . $error);
	}

	# Close existing
	acquire($python_handles_lock);
	if (%python_handles[$script]) {
		debug('closing existing handle');
		closef(%python_handles[$script]);
	}

	# We parse the results in the same thread until we receive a fork command.
	# This allows us to register aliases and stuff.
	%python_handles[$script] = $handle;
	release($python_handles_lock);
	if (thread_callback(\$handle, \$script)) {
		fork(&thread_callback, \$handle, \$script, \%python_objects);
	}
}

sub python_stop {
	$script = $1;

	# Remove it from handles list
	acquire($python_handles_lock);
	if (%python_handles[$script]) {
		closef(%python_handles[$script]);
		%python_handles[$script] = $null;
	}
	release($python_handles_lock);
}
